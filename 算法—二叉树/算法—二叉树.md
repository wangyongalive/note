# 算法---二叉树
@(前端面试)[面试, 算法]


# 二叉树理论基础篇

题目分类大纲如下：           

![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/20210219190809451.png)
说道二叉树，大家对于二叉树其实都很熟悉了，本文呢我也不想教科书式的把二叉树的基础内容在啰嗦一遍，所以一下我讲的都是一些比较重点的内容。
相信只要耐心看完，都会有所收获。

## 二叉树的种类
在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。

### 满二叉树
满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
如图所示：
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/20200806185805576.png)
这棵二叉树为满二叉树，也可以说深度为**k**，有**2^k-1**个节点的二叉树。


### 完全二叉树
什么是完全二叉树？
完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^h -1  个节点。
**大家要自己看完全二叉树的定义，很多同学对完全二叉树其实不是真正的懂了。**

我来举一个典型的例子如题：
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/20200920221638903.png)
相信不少同学最后一个二叉树是不是完全二叉树都中招了。

**之前我们刚刚讲过优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。**

### 二叉搜索树

前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，**二叉搜索树是一个有序树**。
* 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
* 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
* 它的左、右子树也分别为二叉排序树

下面这两棵树都是搜索树
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/20200806190304693.png)

### 平衡二叉搜索树
平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
如图：
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/20200806190304693.png)



最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。
**C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树**，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。
**所以大家使用自己熟悉的编程语言写算法，一定要知道常用的容器底层都是如何实现的，最基本的就是map、set等等，否则自己写的代码，自己对其性能分析都分析不清楚！**


## 二叉树的存储方式
**二叉树可以链式存储，也可以顺序存储。**
那么链式存储方式就用指针， 顺序存储的方式就是用数组。
顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在散落在各个地址的节点串联一起。
链式存储如图：
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/2020092019554618.png)
链式存储是大家很熟悉的一种方式，那么我们来看看如何顺序存储呢？
其实就是用数组来存储二叉树，顺序存储的方式如图：
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/20200920200429452.png)
用数组来存储二叉树如何遍历的呢？
**如果父节点的数组下表是i，那么它的左孩子就是i * 2 + 1，右孩子就是 i * 2 + 2。**
但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。
**所以大家要了解，用数组依然可以表示二叉树。**

## 二叉树的遍历方式
关于二叉树的遍历方式，要知道二叉树遍历的基本方式都有哪些。
一些同学用做了很多二叉树的题目了，可能知道前中后序遍历，可能知道层序遍历，但是却没有框架。
我这里把二叉树的几种遍历方式列出来，大家就可以一一串起来了。
二叉树主要有两种遍历方式：
1. 深度优先遍历：先往深走，遇到叶子节点再往回走。
2. 广度优先遍历：一层一层的去遍历。

**这两种遍历是图论中最基本的两种遍历方式**，后面在介绍图论的时候 还会介绍到。
那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：
* 深度优先遍历
    * 前序遍历（递归法，迭代法）
    * 中序遍历（递归法，迭代法）
    * 后序遍历（递归法，迭代法）
* 广度优先遍历
    * 层次遍历（迭代法）
    
在深度优先遍历中：有三个顺序，前中后序遍历， 有同学总分不清这三个顺序，经常搞混，我这里教大家一个技巧。
**这里前中后，其实指的就是中间节点的遍历顺序**，只要大家记住 前中后序指的就是中间节点的位置就可以了。
看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式
* 前序遍历：中左右
* 中序遍历：左中右
* 后序遍历：左右中

大家可以对着如下图，看看自己理解的前后中序有没有问题。
最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。
**之前我们讲栈与队列的时候，就说过栈其实就是递归的一种是实现结构**，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。
而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。
**这里其实我们又了解了栈与队列的一个应用场景了。**
具体的实现我们后面都会讲的，这里大家先要清楚这些理论基础。

## 二叉树的定义
刚刚我们说过了二叉树有两种存储方式顺序存储，和链式存储，顺序存储就是用数组来存，这个定义没啥可说的，我们来看看链式存储的二叉树节点的定义方式。
C++代码如下：
```
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```
大家会发现二叉树的定义 和链表是差不多的，相对于链表 ，二叉树的节点里多了一个指针， 有两个指针，指向左右孩子.
这里要提醒大家要注意二叉树节点定义的书写方式。
**在现场面试的时候 面试官可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来。**
因为我们在刷leetcode的时候，节点的定义默认都定义好了，真到面试的时候，需要自己写节点定义的时候，有时候会一脸懵逼！

## 总结
二叉树是一种基础数据结构，在算法面试中都是常客，也是众多数据结构的基石。
本篇我们介绍了二叉树的种类、存储方式、遍历方式以及定义，比较全面的介绍了二叉树各个方面的重点，帮助大家扫一遍基础。
**说道二叉树，就不得不说递归，很多同学对递归都是又熟悉又陌生，递归的代码一般很简短，但每次都是一看就会，一写就废。**
## 其他语言版本
Java：
```java
public class TreeNode {
    int val;
  	TreeNode left;
  	TreeNode right;
  	TreeNode() {}
  	TreeNode(int val) { this.val = val; }
  	TreeNode(int val, TreeNode left, TreeNode right) {
    		this.val = val;
    		this.left = left;
    		this.right = right;
  	}
}
```
Python：
```python
class TreeNode: 
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
```
Go：
```go
type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}
```
JavaScript：
```javascript
function TreeNode(val, left, right) {
    this.val = (val===undefined ? 0 : val)
    this.left = (left===undefined ? null : left)
    this.right = (right===undefined ? null : right)
}
```



## 二叉树的递归遍历
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635429213630.png)
```javascript
var preorderTraversal = function (root) {
  let res = []
  const dfs = function (root) {
    if (root === null) return
    //先序遍历所以从父节点开始
    res.push(root.val)
    //递归左子树
    dfs(root.left)
    //递归右子树
    dfs(root.right)
  }
  //只使用一个参数 使用闭包进行存储结果
  dfs(root)
  return res
}
```
```javascript
var inorderTraversal = function (root) {
  let res = []
  const dfs = function (root) {
    if (root === null) {
      return
    }
    dfs(root.left)
    res.push(root.val)
    dfs(root.right)
  }
  dfs(root)
  return res
}
```

```javascript
var postorderTraversal = function (root) {
  let res = []
  const dfs = function (root) {
    if (root === null) {
      return
    }
    dfs(root.left)
    dfs(root.right)
    res.push(root.val)
  }
  dfs(root)
  return res
}
```

## 二叉树的迭代遍历
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635432314867.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635432857805.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/008eGmZEly1gnbmss7603g30eq0d4b2a.gif)
```javascript
// 入栈 右 -> 左
// 出栈 中 -> 左 -> 右
var preorderTraversal = function(root, res = []) {
    if(!root) return res;
    const stack = [root];
    let cur = null;
    while(stack.length) {
        cur = stack.pop();
        res.push(cur.val);
        cur.right && stack.push(cur.right);
        cur.left && stack.push(cur.left);
    }
    return res;
};
```
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635432957093.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/008eGmZEly1gnbmuj244bg30eq0d4kjm 1.gif)
```javascript
// 入栈 左 -> 右
// 出栈 左 -> 中 -> 右
var inorderTraversal = function (root, res = []) {
    const stack = [];
    let cur = root;
    while (stack.length || cur) {
        if (cur) {
            stack.push(cur);
            // 左
            cur = cur.left;
        } else {
            // --> 弹出 中
            cur = stack.pop();
            res.push(cur.val);
            // 右
            cur = cur.right;
        }
    };
    return res;
};
```
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635432987478.png)

![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635432976176.png)
```javascript
// 入栈 左 -> 右
// 出栈 中 -> 右 -> 左 结果翻转
var postorderTraversal = function (root, res = []) {
    if (!root) return res;
    const stack = [root];
    let cur = null;
    while (stack.length) {
        cur = stack.pop();
        res.push(cur.val);
        cur.left && stack.push(cur.left);
        cur.right && stack.push(cur.right);
    };
    return res.reverse();
};
```



----
## 层次遍历
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635578257106.jpeg)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635578926747.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/11111.gif)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635579441927.png)

### 二叉树的层序遍历
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635578306621.png)
```javascript
var levelOrder = function (root) {
    const ret = [];
    if (!root) {
        return ret;
    }
    const q = [root]; // 新建一个队列，并将根节点入队
    while (q.length) {
        const currentLevelSize = q.length;
        const currentLevel = []
        for (let i = 1; i <= currentLevelSize; ++i) {
            const node = q.shift(); // 对头出队并访问
            currentLevel.push(node.val);
            if (node.left) q.push(node.left);
            if (node.right) q.push(node.right);
        }
        ret.push(currentLevel)
    }
    return ret; // 
};
```
```javascript
var levelOrder = function (root) {
    const ret = [];
    if (!root) {
        return ret;
    }
    const q = [root];
    while (q.length) {
        const node = q.shift();
        ret.push(node.val);
        if (node.left) q.push(node.left);
        if (node.right) q.push(node.right);

    }
    return ret; // [1,2,4]
};
```
### 二叉树的右视图
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635579349754.png)
>思路：
层序遍历的时候，判断是否遍历到单层的最后面的元素，如果是，就放进result数组中，随后返回result就可以了。
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function (root) {
    const ret = [];
    if (!root) {
        return ret;
    }
    const q = [root]; // 新建一个队列，并将根节点入队
    while (q.length) {
        const currentLevelSize = q.length;
        const currentLevel = []
        for (let i = 1; i <= currentLevelSize; ++i) {
            const node = q.shift(); // 对头出队并访问
            if (i === currentLevelSize) {
                currentLevel.push(node.val);
            }

            if (node.left) q.push(node.left);
            if (node.right) q.push(node.right);
        }
        ret.push(currentLevel)
    }
    return ret; 
};
```
### 二叉树的层平均值
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635579691518.png)
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var averageOfLevels = function (root) {
    const ret = [];
    if (!root) {
        return ret;
    }
    const q = [root]; // 新建一个队列，并将根节点入队
    while (q.length) {
        const currentLevelSize = q.length;
        const currentLevel = []
        for (let i = 1; i <= currentLevelSize; ++i) {
            const node = q.shift(); // 对头出队并访问
            currentLevel.push(node.val);
            if (node.left) q.push(node.left);
            if (node.right) q.push(node.right);
        }
        ret.push(currentLevel.reduce((pre, cur) => pre + cur) / currentLevel.length)
    }
    return ret; // 
};
```
### N 叉树的层序遍历
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635579918066.png)
```javascript
/**
 * // Definition for a Node.
 * function Node(val,children) {
 *    this.val = val;
 *    this.children = children;
 * };
 */

/**
 * @param {Node|null} root
 * @return {number[][]}
 */
var levelOrder = function (root) {
    const ret = [];
    if (!root) {
        return ret;
    }
    const q = [root]; // 新建一个队列，并将根节点入队
    while (q.length) {
        const currentLevelSize = q.length;
        const currentLevel = []
        for (let i = 1; i <= currentLevelSize; ++i) {
            const node = q.shift(); // 对头出队并访问
            currentLevel.push(node.val);
            // 这里不再是 ndoe.left node.right 而是循坏node.children
            // for (let children of node.children) {
            //     q.push(children)
            // }
            node.children.forEach(child => {
                q.push(child);
            });
        }
        ret.push(currentLevel)
    }
    return ret; // 
};
```

### 在每个树行中找最大值
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635580168110.png)
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var largestValues = function (root) {
    const ret = [];
    if (!root) {
        return ret;
    }
    const q = [root]; // 新建一个队列，并将根节点入队
    while (q.length) {
        const currentLevelSize = q.length;
        const currentLevel = []
        for (let i = 1; i <= currentLevelSize; ++i) {
            const node = q.shift(); // 对头出队并访问
            currentLevel.push(node.val);
            if (node.left) q.push(node.left);
            if (node.right) q.push(node.right);
        }
        ret.push(Math.max(...currentLevel))
    }
    return ret; // 
};
```
### 填充每个节点的下一个右侧节点指针
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635580983708.png)
```javascript
/**
 * // Definition for a Node.
 * function Node(val, left, right, next) {
 *    this.val = val === undefined ? null : val;
 *    this.left = left === undefined ? null : left;
 *    this.right = right === undefined ? null : right;
 *    this.next = next === undefined ? null : next;
 * };
 */

/**
 * @param {Node} root
 * @return {Node}
 */
var connect = function (root) {
    if (!root) {
        return root;
    }
    const q = [root]; // 新建一个队列，并将根节点入队
    while (q.length) {
        const currentLevelSize = q.length;
        for (let i = 1; i <= currentLevelSize; ++i) {
            const node = q.shift(); // 对头出队并访问
            if (i < currentLevelSize) {
                node.next = q[0]
            }
            if (node.left) q.push(node.left);
            if (node.right) q.push(node.right);
        }
    }
    return root; // 
};
```

### 填充每个节点的下一个右侧节点指针 II
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635581120470.png)
```javascript
/**
 * // Definition for a Node.
 * function Node(val, left, right, next) {
 *    this.val = val === undefined ? null : val;
 *    this.left = left === undefined ? null : left;
 *    this.right = right === undefined ? null : right;
 *    this.next = next === undefined ? null : next;
 * };
 */

/**
 * @param {Node} root
 * @return {Node}
 */
var connect = function (root) {
    if (!root) {
        return root;
    }
    const q = [root]; // 新建一个队列，并将根节点入队
    while (q.length) {
        const currentLevelSize = q.length;
        for (let i = 1; i <= currentLevelSize; ++i) {
            const node = q.shift(); // 对头出队并访问
            if (i < currentLevelSize) {
                node.next = q[0]
            }
            if (node.left) q.push(node.left);
            if (node.right) q.push(node.right);
        }
    }
    return root; // 
};
```

### 二叉树的最大深度
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635581394719.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635581420335.png)
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
// var maxDepth = function (root) {

//     if (!root) {
//         return 0
//     } else {
//         const left = maxDepth(root.left);
//         const right = maxDepth(root.right);
//         return Math.max(left, right) + 1;
//     }
// };

var maxDepth = function (root) {
    if (!root) {
        return root;
    }
    const q = [root]; // 新建一个队列，并将根节点入队
    let dep = 0;
    while (q.length) {
        const currentLevelSize = q.length;
        dep++;
        for (let i = 1; i <= currentLevelSize; ++i) {
            const node = q.shift(); // 对头出队并访问
            if (node.left) q.push(node.left);
            if (node.right) q.push(node.right);
        }
    }
    return dep; // 
};
```

### 二叉树的最小深度
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635581795601.png)
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function (root) {
    if (!root) {
        return 0;
    }
    const q = [root]; // 新建一个队列，并将根节点入队
    let dep = 0;;
    while (q.length) {
        dep++;
        const currentLevelSize = q.length;
        const currentLevel = []
        for (let i = 1; i <= currentLevelSize; ++i) {
            const node = q.shift(); // 对头出队并访问
            if (!node.left && !node.right) return dep // 遇到叶子节点马上退出
            if (node.left) q.push(node.left);
            if (node.right) q.push(node.right);
        }
    }
};
```
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635581935222.png)


## 翻转二叉树
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635582648972.png)
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {TreeNode}
 */
var invertTree = function (root) {
    if (!root) {
        return null;
    }
    const q = [root]; // 新建一个队列，并将根节点入队
    while (q.length) {
        const currentLevelSize = q.length;
        for (let i = 1; i <= currentLevelSize; ++i) {
            const node = q.shift(); // 对头出队并访问
            [node.left, node.right] = [node.right, node.left] // 交换左右子树
            if (node.left) q.push(node.left);
            if (node.right) q.push(node.right);
        }
    }
    return root; // 
};
```
```javascript
const invertTree = (root) => {
  if (root == null) { // 遍历到null节点时，不用翻转，直接返回它本身
    return root;
  }
  invertTree(root.left);
  invertTree(root.right);
  // 后序遍历
  const temp = root.left;
  root.left = root.right;
  root.right = temp;
  return root;
};


const invertTree = (root) => {
  if (root == null) { // 遍历到null节点时，不用翻转，直接返回它本身
    return root;
  }
  const temp = root.left;
  root.left = root.right;
  root.right = temp;
  // 内部的翻转交给递归去做
  invertTree(root.left);
  invertTree(root.right);
  return root;
};


// 两种分别是后序遍历和前序遍历。都是基于DFS，都是先遍历根节点、再遍历左子树、再右子树。
// 唯一的区别是：
// 前序遍历：将「处理当前节点」放到「递归左子树」之前。
// 后序遍历：将「处理当前节点」放到「递归右子树」之后。
// 这个「处理当前节点」，就是交换左右子树 ，就是解决问题的代码：
const temp = root.left;
root.left = root.right;
root.right = temp;
```

## 对称二叉树
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635585403659.png)
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {
    if (!root) {
        return true;
    }
    const q = [root.left, root.right]; // 新建一个队列，并将根节点入队
    while (q.length) {
        const currentLevelSize = q.length;
        for (let i = 1; i <= currentLevelSize; i += 2) {
            const nodeLeft = q.shift(); // 对头出队并访问
            const nodeRight = q.shift(); // 对头出队并访问
            if (!nodeLeft && !nodeRight) {
                continue
            }
            if (!nodeLeft || !nodeRight) {
                return false
            }
            if (nodeLeft.val !== nodeRight.val) {
                return false
            }
            q.push(nodeLeft.left, nodeRight.right);
            q.push(nodeLeft.right, nodeRight.left);
        }
    }
    return true; // 
};
```
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function (root) {
    //使用递归遍历左右子树 递归三部曲
    // 1. 确定递归的参数 root.left root.right和返回值true false 
    const compareNode = function (left, right) {
        //2. 确定终止条件 空的情况
        if (!left && !right) { // 都为空
            return true;
        }
        if (!right || !left) { // 其中一个为空
            return false;
        }
        if (left.val !== right.val) { // val值不相同
            return false;
        }
        //3. 确定单层递归逻辑
        let outSide = compareNode(left.left, right.right);
        let inSide = compareNode(left.right, right.left);
        return outSide && inSide;
    }
    if (root === null) {
        return true;
    }
    return compareNode(root.left, root.right);
};
```


## 相同的树
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636017513118.png)
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
const isSameTree = function (p, q) {
    //使用递归遍历两棵树 递归三部曲
    // 1. 确定递归的参数 left  right和返回值true false 
    const compareNode = (p, q) => {
        //2. 确定终止条件 空的情况
        if (!p && !q) {
            return true;
        }
        if (!p || !q) {
            return false;
        }
        if (p.val !== q.val) {
            return false
        }
        //3. 确定单层递归逻辑
        let outSide = compareNode(p.left, q.left);
        let inSide = compareNode(p.right, q.right);
        return outSide && inSide;
    }
    return compareNode(p, q)
};
```
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function (left,right) {
    if (!left && !right) {
        return true;
    }
    const q = [left, right]; // 新建一个队列，并将根节点入队
    while (q.length) {
        const currentLevelSize = q.length;
        for (let i = 1; i <= currentLevelSize; i += 2) {
            const nodeLeft = q.shift(); // 对头出队并访问
            const nodeRight = q.shift(); // 对头出队并访问
            if (!nodeLeft && !nodeRight) {
                continue
            }
            if (!nodeLeft || !nodeRight) {
                return false
            }
            if (nodeLeft.val !== nodeRight.val) {
                return false
            }
            q.push(nodeLeft.left, nodeRight.left);
            q.push(nodeLeft.right, nodeRight.right);
        }
    }
    return true; // 
};
```

## 二叉树的最大深度
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635586693988.png)
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {
    if (!root) {
        return 0  // 递归结束
    } else {
        const left = maxDepth(root.left);
        const right = maxDepth(root.right);
        return Math.max(left, right) + 1;
    }
};

var maxDepth = function (root) {
    if (!root) {
        return root;
    }
    const q = [root]; // 新建一个队列，并将根节点入队
    let dep = 0;
    while (q.length) {
        const currentLevelSize = q.length;
        dep++;
        for (let i = 1; i <= currentLevelSize; ++i) {
            const node = q.shift(); // 对头出队并访问
            if (node.left) q.push(node.left);
            if (node.right) q.push(node.right);
        }
    }
    return dep; // 
};
```

## 二叉树的最小深度
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635587875167.png)
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
// BFS 
var minDepth = function (root) {
    if (!root) {
        return 0;
    }
    const q = [root]; // 新建一个队列，并将根节点入队
    let dep = 0;;
    while (q.length) {
        dep++;
        const currentLevelSize = q.length;
        for (let i = 1; i <= currentLevelSize; ++i) {
            const node = q.shift(); // 对头出队并访问
            if (!node.left && !node.right) return dep // 访问到了叶子节点 直接返回
            if (node.left) q.push(node.left);
            if (node.right) q.push(node.right);
        }
    }
};


// DFS
/**
    * @param {TreeNode} root
    * @return {number}
    */
var minDepth = (root) => {
    if (root == null) {
        return 0;
    }
    let depth = Infinity; // 当前子树的深度

    if (root.left) { // 左子树存在，用1+左子树的最小深度去刷新depth
        depth = Math.min(depth, 1 + minDepth(root.left));
    }
    if (root.right) { // 由子树存在，用1+右子树的最小深度去刷新depth
        depth = Math.min(depth, 1 + minDepth(root.right));
    }
    if (root.left == null && root.right == null) { // 都不存在
        depth = 1;
    }
    return depth;
};

// DFS
var minDepth = function (root) {
    if (!root) return 0;
    // 到叶子节点 返回 1
    if (!root.left && !root.right) return 1;
    // 只有右节点时 递归右节点
    if (!root.left) return 1 + minDepth(root.right);
    // 只有左节点时 递归左节点
    if (!root.right) return 1 + minDepth(root.left);
    // 左右子树都有
    return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
};
```

## 完全二叉树的节点个数
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635589150674.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635589394141.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635589409777.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635589423539.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635589431632.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635589438522.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635589477570.png)

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function (root) {
    //层序遍历
    if (root === null) {
        return 0;
    }
    let queue = [];
    queue.push(root);
    let nodeNums = 0;
    while (queue.length) {
        let length = queue.length;
        while (length--) {
            let node = queue.shift();
            nodeNums++;
            node.left && queue.push(node.left);
            node.right && queue.push(node.right);
        }
    }
    return nodeNums;
};
```
```javascript
// 递归版本
var countNodes = function (root) {
    //递归法计算二叉树节点数
    // 1. 确定递归函数参数
    const getNodeSum = function (node) {
        //2. 确定终止条件
        if (node === null) {
            return 0;
        }
        //3. 确定单层递归逻辑
        let leftNum = getNodeSum(node.left);
        let rightNum = getNodeSum(node.right);
        return leftNum + rightNum + 1;
    }
    return getNodeSum(root);
};


// 利用完全二叉树性质
var countNodes = function (root) {
    //利用完全二叉树的特点
    if (root === null) {
        return 0;
    }
    let left = root.left;
    let right = root.right;
    let leftHeight = 0, rightHeight = 0;
    while (left) {
        left = left.left;
        leftHeight++;
    }
    while (right) {
        right = right.right;
        rightHeight++;
    }
    if (leftHeight == rightHeight) {
        // return Math.pow(2, leftHeight + 1) - 1;
        return (1 << (leftHeight + 1)) - 1;
    }
    // 不是满二叉树
    return countNodes(root.left) + countNodes(root.right) + 1;
};
```


## 平衡二叉树
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635593923963.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635593931503.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635593945452.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635594162479.png)
```javascript
// var isBalanced = function (root) {
//     return balanced(root) !== -1
// };
// var balanced = function (node) {
//     if (!node) return 0
//     const left = balanced(node.left)
//     const right = balanced(node.right)
//     if (left === -1 || right === -1 || Math.abs(left - right) > 1) {
//         return -1
//     }
//     return Math.max(left, right) + 1
// }

var isBalanced = function (root) {
    //还是用递归三部曲  + 后序遍历 左右中 当前左子树右子树高度相差大于1就返回-1
    // 1. 确定递归函数参数以及返回值
    const getDepth = function (node) {
        // 2. 确定递归函数终止条件
        if (node === null) {
            return 0;
        }
        // 3. 确定单层递归逻辑
        let leftDepth = getDepth(node.left);//左子树高度
        if (leftDepth === -1) {
            return -1;
        }
        let rightDepth = getDepth(node.right);//右子树高度
        if (rightDepth === -1) {
            return -1;
        }
        if (Math.abs(leftDepth - rightDepth) > 1) {
            return -1;
        } else {
            return 1 + Math.max(leftDepth, rightDepth);
        }
    }
    // return getDepth(root) === -1 ? false : true;
    return getDepth(root) !== -1;
};
```

## 二叉树的所有路径
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635597580780.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635596715665.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635597595961.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1635597674686.png)

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
var binaryTreePaths = function (root) {
    //递归遍历+递归三部曲
    let res = [];
    //1. 确定递归函数 函数参数
    const getPath = function (node, curPath) {
        //2. 确定终止条件，到叶子节点就终止
        if (node.left === null && node.right === null) {
            curPath += node.val;
            res.push(curPath);
            return;
        }
        //3. 确定单层递归逻辑
        curPath += node.val + '->';
        node.left && getPath(node.left, curPath);
        node.right && getPath(node.right, curPath);
    }
    getPath(root, '');
    return res;
};
```

## 左叶子之和
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636164703813.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636164830627.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636165658151.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636165796519.png)

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumOfLeftLeaves = function (root) {
    if (!root) {
        return 0
    }
    let q = [root], sum = 0;
    while (q.length) {
        const currentLevelSize = q.length;
        for (let i = 1; i <= currentLevelSize; i++) {
            const node = q.shift()
            if (node.left && !node.left.left && !node.left.right) {
                sum += node.left.val
            }
            node.left && q.push(node.left)
            node.right && q.push(node.right)
        }
    }
    return sum
};
```
```javascript
var sumOfLeftLeaves = function (root) {
    //采用后序遍历 递归遍历
    // 1. 确定递归函数参数
    let sum = 0;
    const nodesSum = function (node) {
        // 2. 确定终止条件
        if (node === null) {
            return 0;
        }
        nodesSum(node.left);
        nodesSum(node.right);
        // 3. 单层递归逻辑
        if (node.left && node.left.left === null && node.left.right === null) {
            sum += node.left.val;
        }
    }
    nodesSum(root);
    return sum
};
```


## 路径总和
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636168507411.png)
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {boolean}
 */
// 深度优先遍历
// 时间复杂度  O(n)
// 空间复杂度 O(n)
var hasPathSum = function(root, targetSum) {
   if(!root) return false;
   let res = false;
   const dfs = (n, s) =>{ // 每个根节点保存值
       // 对根节点的chid依次进行访问
        if(!n.left && !n.right && s === targetSum){ // 叶子节点
            res = true;
        }
       if(n.left) { dfs(n.left, s + n.left.val)}
       if(n.right) {dfs(n.right, s + n.right.val)}
   }
   dfs(root, root.val);
   return res;
};
```

## 路径总和 II
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636168600231.png)
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} targetSum
 * @return {number[][]}
 */
var pathSum = function (root, targetSum) {
    if (!root) return [];
    let res = [];
    const dfs = (n, s, path) => { // 每个根节点保存值
        // 对根节点的chid依次进行访问
        if (!n.left && !n.right && s === targetSum) { // 叶子节点
            res.push(path);
        }
        if (n.left) { dfs(n.left, s + n.left.val, [...path, n.left.val]) }
        if (n.right) { dfs(n.right, s + n.right.val, [...path, n.right.val]) }
    }
    dfs(root, root.val, [root.val]);
    return res;
};
```

## 从中序与后序遍历序列构造二叉树
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636172920422.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/20210203154249860.png)
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} inorder
 * @param {number[]} postorder
 * @return {TreeNode}
 */
var buildTree = function (inorder, postorder) {
    /* 通过 前/后序 遍历确定根节点的位置   中序遍历确定左右子树*/
    if (!postorder.length) return null
    let root = new TreeNode(postorder[postorder.length - 1])
    let mid = inorder.findIndex(number => number === root.val)
    root.left = buildTree(inorder.slice(0, mid), postorder.slice(0, mid))
    root.right = buildTree(inorder.slice(mid + 1, inorder.length), postorder.slice(mid, postorder.length - 1))
    return root
};
```


## 从前序与中序遍历序列构造二叉树
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636173080884.png)
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */
var buildTree = function (preorder, inorder) {
    /* 通过 前/后序 遍历确定根节点的位置   中序遍历确定左右子树*/
    if (!preorder.length) return null
    let root = new TreeNode(preorder[0])
    let midIndex = inorder.findIndex((item) => item === root.val) 
    root.left = buildTree(preorder.slice(1, midIndex + 1), inorder.slice(0, midIndex))
    root.right = buildTree(preorder.slice(midIndex + 1, preorder.length), inorder.slice(midIndex + 1, inorder.length))
    return root
};
```


## 最大二叉树
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636263976934.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636264074249.png)
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {number[]} nums
 * @return {TreeNode}
 */
var constructMaximumBinaryTree = function (nums) {
    if (nums.length === 0) return null
    let max = Math.max(...nums)
    let root = new TreeNode(max)
    root.left = constructMaximumBinaryTree(nums.slice(0, nums.indexOf(max)))
    root.right = constructMaximumBinaryTree(nums.slice(nums.indexOf(max) + 1))
    return root
};
```


## 合并二叉树
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636458688931.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636459496127.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636459501514.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636459545472.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636459584542.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636459607007.png)

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root1
 * @param {TreeNode} root2
 * @return {TreeNode}
 */
var mergeTrees = function (root1, root2) {
    if (!root1 || !root2) { // 如果其中有一个为空，则直接返回
        return root1 || root2
    }
    root1.val += root2.val;
    root1.left = mergeTrees(root1.left, root2.left)
    root1.right = mergeTrees(root1.right, root2.right)
    return root1;
};

var mergeTrees = function (root1, root2) {
    if (!root1 || !root2) { // 如果其中有一个为空，则直接返回
        return root1 || root2
    }
    let root = new TreeNode(0); // 重新定义一棵树
    root.val = root1.val + root2.val;
    root.left = mergeTrees(root1.left, root2.left)
    root.right = mergeTrees(root1.right, root2.right)
    return root;
};
```

## 二叉搜索树中的搜索
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636547579749.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636547926519.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636549241095.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636549252811.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636549284838.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636549297768.png)
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} val
 * @return {TreeNode}
 */
var searchBST = function (root, val) {
    if (!root || root.val === val) {
        return root;
    }
    if (root.val > val)
        return searchBST(root.left, val);
    if (root.val < val)
        return searchBST(root.right, val);
};
```
```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} val
 * @return {TreeNode}
 */
var searchBST = function (root, val) {
    while (root !== null) {
        if (root.val > val)
            root = root.left;
        else if (root.val < val)
            root = root.right;
        else
            return root;
    }
    return null;
};
```


### 验证二叉搜索树
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636550635618.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91/1636550671149.png)

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isValidBST = function (root) {
    let res = []
    const dfs = function (root) {
        if (root === null) {
            return
        }
        dfs(root.left)
        res.push(root.val)
        dfs(root.right)
    }
    dfs(root)
    for (let index = 0, len = res.length; index < len; index++) {
        if (res[index] >= res[index + 1]) {
            return false;
        }
    }
    return true;
};
```