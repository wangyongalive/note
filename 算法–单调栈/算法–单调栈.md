# 算法--单调栈
@(前端面试)[面试]
### 每日温度
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%93%E5%8D%95%E8%B0%83%E6%A0%88/1638892650362.png)
```javascript
/**
 * @param {number[]} T
 * @return {number[]}
 */
 // 单调递减栈
const dailyTemperatures = function (T) {
    let len = T.length;
    let res = Array(len).fill(0), stack = [];
    for (let i = 0; i < len; i++) {
        // 当栈不为空且当前的遍历值大于栈顶元素，则出栈
        while (stack.length && T[stack[stack.length - 1]] < T[i]) {
            let index = stack.pop(); // 
            res[index] = i - index; // 计算距离
        }
        stack.push(i);
    }
    return res
};
```

### 下一个更大元素 I
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%93%E5%8D%95%E8%B0%83%E6%A0%88/1638892684544.png)
```javascript
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
// 单调递增栈：只有比栈顶小的才能入栈，否则就把栈顶元素依次出栈后，再入栈。适用于求解第一个大于该位置元素的数。
// 单调递减栈：与单调递增栈相反。适用于求解第一个小于该位置元素的数。
var nextGreaterElement = function (nums1, nums2) {
    let stack = [];
    let map = new Map();
    for (let i = 0; i < nums2.length; i++) {
        while (stack.length && nums2[i] > nums2[stack[stack.length - 1]]) {
            let index = stack.pop();
            map.set(nums2[index], nums2[i]); // 保存数值
        }
        stack.push(i);
    }
    // console.log(map)
    let res = [];
    // 遍历数组1中的数据，没有的话就是-1
    for (let j = 0; j < nums1.length; j++) {
        res[j] = map.get(nums1[j]) || -1;
    }
    return res;
};
```


### 下一个更大元素 II
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%93%E5%8D%95%E8%B0%83%E6%A0%88/1638968759783.png)
```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var nextGreaterElements = function (nums) {
    let stack = [];
    let res = new Array(nums.length).fill(-1);
    // 遍历两遍数组
    for (let i = 0; i < nums.length * 2; i++) {
        while (
            stack.length &&
            nums[i % nums.length] > nums[stack[stack.length - 1]]
        ) {
            let index = stack.pop();
            res[index] = nums[i % nums.length];
        }
        stack.push(i % nums.length);
    }
    return res;
};
```


### 接雨水
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%93%E5%8D%95%E8%B0%83%E6%A0%88/1638970914377.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%93%E5%8D%95%E8%B0%83%E6%A0%88/1638970936675.png)
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%93%E5%8D%95%E8%B0%83%E6%A0%88/1638971069721.png)
```javascript
/**
 * @param {number[]} height
 * @return {number}
 */
var trap = function (height) {
    const n = height.length;
    if (n == 0) {
        return 0;
    }

    const leftMax = new Array(n).fill(0);
    leftMax[0] = height[0];
    for (let i = 1; i < n; ++i) {
        leftMax[i] = Math.max(leftMax[i - 1], height[i]);
    }

    const rightMax = new Array(n).fill(0);
    rightMax[n - 1] = height[n - 1];
    for (let i = n - 2; i >= 0; --i) {
        rightMax[i] = Math.max(rightMax[i + 1], height[i]);
    }

    let ans = 0;
    for (let i = 0; i < n; ++i) {
        ans += Math.min(leftMax[i], rightMax[i]) - height[i];
    }
    return ans;
};
```

### 柱状图中最大的矩形
![Alt text](https://raw.githubusercontent.com/wangyongalive/note/main/%E7%AE%97%E6%B3%95%E2%80%93%E5%8D%95%E8%B0%83%E6%A0%88/1638978120478.png)
```javascript
const largestRectangleArea = (heights) => {
    let maxArea = 0
    const stack = []
    heights = [0, ...heights, 0]
    for (let i = 0; i < heights.length; i++) {
        while (heights[i] < heights[stack[stack.length - 1]]) { // 当前bar比栈顶bar矮
            const stackTopIndex = stack.pop() // 栈顶元素出栈，并保存栈顶bar的索引
            maxArea = Math.max(               // 计算面积，并挑战最大面积
                maxArea,                        // 计算出栈的bar形成的长方形面积
                heights[stackTopIndex] * (i - stack[stack.length - 1] - 1)
            )
        }
        stack.push(i)                       // 当前bar比栈顶bar高了，入栈
    }
    return maxArea
}
```